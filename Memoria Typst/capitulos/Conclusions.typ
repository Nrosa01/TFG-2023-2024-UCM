Once the tests were completed, the results were analyzed. Instead of differentiating between performance and usability, the decision was made to evaluate the value provided by each simulator separately. Finally, it concludes with a global view and proposes improvements for future versions.

The most notable thing about the tests is the great difference in performance between the simulators implemented on the CPU and the one implemented on the GPU. However, the cost of implementation and extension is much higher. In this simulator, usability could not be tested with users because this required compiling the project, which requires certain tools that many users are not willing to install. A GPU implementation may be ideal when high performance is required but the behavior to be achieved is highly specific and moderately complex. An implementation of these characteristics may be useful for cellular automata research in which a large amount of particles must be processed simultaneously to search for large-dimensional patterns that could not be detected with a CPU implementation. "It could be interesting to investigate a system that allows for the generalization of rules to create cellular automata on the GPU in a flexible manner This has not been possible with sand simulators because, in these, a particle can modify its neighbors. However, in cellular automata, each cell can at most modify itself, which could simplify the implementation..

The C++ implementation was made as a basis to measure the others. This has allowed us to quantify the performance penalty incurred by the flexibility of using an interpreted language such as Lua, even in its JIT version, as well as using WebAssembly. The development of sand simulators in C++ incurs in the same problem as the GPU, access to the code and development tools are required to be able to extend it.

Regarding the implementation in Lua, the performance it can achieve is surprising given the flexibility it offers. However, developing interfaces is more complex due to the scarcity of libraries for it. With enough work, this implementation has the potential to be the most balanced solution suitable for arena simulators on CPU. Through multithreading the performance achieved turns out to be higher than expected. If a target audience with a more technical profile is assumed, this implementation is much more powerful. It offers even more control than Blockly's, and tests show that developing particles by programming becomes just as fast and simple as using blocks, For use in video games, this option may become viable with a little more work to simulate only groups of active particles and not all of the particles in memory.

Finally, the implementation in Rust with Blockly stands out for being slower than expected. The learning curve through blocks was higher than expected, however, after this, users seem to be able to develop particles with ease without requiring programming notions.This implementation turns out to be the most accessible because it only requires a browser, which is software that any current smart device has. Due to its performance, this implementation is not ideal for exploring simulations of great complexity or size. This could be alleviated by implementing multithreading, however, due to Rust's memory safety rules and the low maturity of multithreading in WebAssembly, this task results in very high complexity, with the possibility that it cannot be achieved. Therefore, this version turns out to be the most suitable for simulations of low complexity and size. It can also be considered as a viable option for teaching logic and introducing arena simulators and, with certain modifications, cellular automata.

In conclusion, developing simulators on GPU turns out to be a good option when great computing power is required when the size of the simulation is very large. On CPU, a native version in Lua with multithreading offers decent performance that allows you to explore various types of simulations with ease as long as they are not excessively complex. Finally, an implementation in Rust with Blockly turns out to be the most accessible and simple option, but with more limited performance.